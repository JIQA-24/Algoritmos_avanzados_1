// Divad Alejandro Shriqui Garrón A01366907
// José Israel Quintero Alfaro    A01366686

#include <iostream>
#include <fstream>
#include <cstring>
#include <vector>

using namespace std;

int contador = 0;
int tota = 0;

//******************** Parte 1 ********************

vector<int> PreProcesamiento(string Mcode){ // Preparamos los string para ser procesados en la función. Haciendolos vectores y devolvemos vectores
    int l = Mcode.length();
    vector<int> kmp(1,0);
    int pPatron = 0;

    for (int iter = 1; iter < l; iter++){
        if(Mcode[iter] == Mcode[pPatron]){
            pPatron++;
            kmp.push_back(pPatron);
        }else{
            pPatron = 0;
            kmp.push_back(pPatron);
        }
    }
    return kmp;
}

//o(n)
//encontrar el Virus en el string
void KMP(string Transmision, string Mcode, vector<int> kmp, int cont){
    int tamanoPatron = Mcode.length();
    int posPatron = 0;

    for (int i = 0; i < Transmision.length(); i++){
    	cont++; // Iniciamos un contador
        if (Mcode[posPatron] == Transmision[i]){
            posPatron++;
            if (posPatron == tamanoPatron){   // Marcamos la posición de busqueda del patrón
                int nuevaPosicion = i - (tamanoPatron - 1);
                nuevaPosicion = nuevaPosicion + 1; //Por que es Base 1;
                cout << tota+nuevaPosicion << " " ; // Imprimimos la posicion, que es el total de espacios mas el inicio del patrón
                posPatron = kmp[posPatron - 1];
                contador = contador + 1;
            }
        }else{ // Retrocedemos
            if (posPatron != 0){
                posPatron = kmp[posPatron - 1];
                i--;
            }
        }
    }
    tota=tota+cont; // Agregamos al total el contador de esta linea
}

//******************** Parte 2 ********************

string aumenta(string S){
  string s = "";
  for (char c:S){
    s = s+"|"+c;
  }
  return s+"|";
}

pair<int,int> manacher(string S){

  pair<int,int> res(0,0); // resultado (inicio, longitud)
  if (S.length() == 0){ // S es nulo
    return res;
  }
  
  string T = aumenta(S);  // llamar a funcion
  int N = T.length();
  // longitud y centro del maximo palindromo encontrado
  int maxLong=1, maxCentro=1; // Hasta ahora posicion 1
  int L[N];
  int C = 1;
  int Li = 0, Ri = 0;
  bool expansion = false; // true si requiera expansion

  L[0]=0; L[1]=1;
  for (Ri=2; Ri<N; Ri++){
    expansion = false;
    Li = C - (Ri-C);
    if ((C+L[C])-Ri >= 0){
      if(L[Li] < (C+L[C])-Ri) // Caso 1
				L[Ri] = L[Li];
			else if(L[Li] == (C+L[C])-Ri && (C+L[C]) == N-1) // Caso 2
				L[Ri] = L[Li];
			else if(L[Li] == (C+L[C])-Ri && (C+L[C]) < N-1){ // Caso 3
					L[Ri] = L[Li];
					expansion = true; // requiere expansion
			}
			else if(L[Li] > (C+L[C])-Ri){ // Caso 4
				L[Ri] = (C+L[C])-Ri;
				expansion = true; // requiere expansion
			}
    }
    else{
      L[Ri] = 0;
      expansion = true;  // requiere expansion
    }
    if (expansion) // hacer la expansion hasta donde se pueda
      while ((Ri + L[Ri]) < N && (Ri - L[Ri]) > 0
             && T[Ri+L[Ri]+1] == T[Ri-L[Ri]-1])
        L[Ri]++;
    if (Ri + L[Ri] > (C + L[C]))
      // si el nuevo palï¿½ndromo se expande mas alla de C
			C = Ri;
    if(L[Ri] > maxLong){
      // Guardar longitud y centro del palindromo mas grande,
      // hasta ahora
			maxLong = L[Ri];
			maxCentro = Ri;
		}
  }
  // obtener inicio y longitud del maximo palindromo encontrado
  // recordando que la longitud de T es el doble de la de S
  res.first = (maxCentro - maxLong)/2; // inicio en S
  res.second = maxLong; // longitud en S
  return res;
}

//******************** Parte 3 ********************

void Printsubstr(char* X, char* Y, int m, int n)
{
    // Crea una tabla para guardar los Substring comunes
    int substringSuffx[m + 1][n + 1];
 
    // Longitud del Substring Común
    int len = 0;
 
    // Declaramos las variables para almacenar el espacio
    int row, col;
 
    // Construcción del SubStringSuffx
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0 || j == 0)
                substringSuffx[i][j] = 0;
 
            else if (X[i - 1] == Y[j - 1]) {
                substringSuffx[i][j] = substringSuffx[i - 1][j - 1] + 1;
                if (len < substringSuffx[i][j]) {
                    len = substringSuffx[i][j];
                    row = i;
                    col = j;
                }
            }
            else
                substringSuffx[i][j] = 0;
        }
    }
 
    if (len == 0) {
        cout << "No Existe SubString común";
        return;
    }
    int contador;
    contador = 0;
 
    // Guardamos el espacio para el resultado
    char* resultStr = (char*)malloc((len + 1) * sizeof(char));
 
    while (substringSuffx[row][col] != 0) {
        resultStr[--len] = X[row - 1]; // or Y[col-1]
        
 
        // Nos movemos diagonalmente a la anterior casilla
        row--;
        col--;
        
        contador ++;
        
        
    }
 
    // Imprime el substring comun mas largo y su posición
    
    cout << "SubString Comun Mas Largo: " << resultStr << "\n";
    //cout<< contador;
    cout << row-contador+1 << "  "<<row+1; //Porque la base es 1
}



int main(){
    int actividades, secuencia, N; // Declaración de variables
    string virus, codigo;

    secuencia = 0;
    actividades = 0;


    ifstream archivo1("transmission1.txt"); // leemos el .txt de transmission
    string transmission1;
    ifstream archivo12("transmission1.txt");
    string transmission12;
    ifstream archivo13("transmission1.txt");
    string transmission13;
    
    string transmision1String( (istreambuf_iterator<char>(archivo1) ), // Convertimos el .txt a String para las siguientes partes
        (istreambuf_iterator<char>()    ) );
                  


    ifstream archivo2("transmission2.txt"); // Leemos el segundo txt de transmission
    string transmission2;
    ifstream archivo22("transmission2.txt");
    string transmission22;
    ifstream archivo23("transmission2.txt");
    string transmission23;
    
    string transmision2String( (istreambuf_iterator<char>(archivo2) ), // Convertimos el .txt a String
        (istreambuf_iterator<char>()    ) );
        
        
        // Leemos los codigos mcode.txt y los convertimos a Strings

    ifstream archivo3("mcode1.txt");
    string mcode1;
    archivo3 >> mcode1;

    ifstream archivo4("mcode2.txt");
    string mcode2;
    archivo4 >> mcode2;

    ifstream archivo5("mcode3.txt");
    string mcode3;
    archivo5 >> mcode3;

//******************** Actividad 1 ******************** 
//******************* transmission1 ******************* 

    contador = 0;
    tota = 0;
    while(archivo1 >> transmission1) {  
        vector<int> preKMP = PreProcesamiento(mcode1);
        int conta=0;
        KMP(transmission1,mcode1,preKMP,conta);
         
    }

    if (contador != 0){
        cout << "true" << " " << "\n";
    }
    else{
        cout << "false" << "\n";
    } 

    contador = 0;
    tota = 0;
    archivo12.seekg(0);
    while(archivo12 >> transmission1) {
        vector<int> preKMP = PreProcesamiento(mcode2); // Preparamos el vector y mandamos los datos necesarios para el algoritmo KMP
        int conta=0;
        KMP(transmission1,mcode2,preKMP,conta);
    }

    if (contador != 0){
        cout << "true" << " " << "\n";// Si se presenta similitud, el contador vuelve con datos y imprime true
    }
    else{
        cout << "false" << "\n";
    } 

    contador = 0;
    tota = 0;
    archivo13.seekg(0);
    while(archivo13 >> transmission1) {        
        vector<int> preKMP = PreProcesamiento(mcode3);
        int conta=0;
        KMP(transmission1,mcode3,preKMP,conta); 
    }

    if (contador != 0){
        cout << "true" << " " << "\n";
    }
    else{
        cout << "false" << "\n";
    } 

//******************* transmission2 *******************
    contador = 0;
    tota = 0;
    while(archivo2 >> transmission1) {      
        vector<int> preKMP = PreProcesamiento(mcode1);
        int conta=0;
        KMP(transmission1,mcode1,preKMP,conta);
    }

    if (contador != 0){
        cout << "true" << " " << "\n";
    }
    else{
        cout << "false" << "\n";
    }

    contador = 0;
    tota = 0;
    archivo22.seekg(0);
    while(archivo22 >> transmission1) {        
        vector<int> preKMP = PreProcesamiento(mcode2);
        int conta=0;
        KMP(transmission1,mcode2,preKMP,conta); 
    }

    if (contador != 0){
        cout << "true" << " " << "\n";
    }
    else{
        cout << "false" << "\n";
    }

    contador = 0;
    tota = 0;
    archivo23.seekg(0);
    while(archivo23 >> transmission1) {
        vector<int> preKMP = PreProcesamiento(mcode3);
        int conta=0;
        KMP(transmission1,mcode3,preKMP,conta); 
    }

    if (contador != 0){
        cout << "true" << " " << "\n";
    }
    else{
        cout << "false" << "\n";
    } 
    
    cout << "\n";

//******************** Actividad 2 ******************** 
	cout << "\nParte 2 \n";
	pair<int,int> res = manacher(transmision1String);// Creamos el pay y mandamos a la funcion manacher los strings para analizar los palindromos.
  	cout << res.first << "  " << res.first+res.second << "\n";
  	
  	pair<int,int> res2 = manacher(transmision2String);
  	cout << res2.first << "  " << res2.first+res2.second<< "\n"; // Imprimimos el resultado del algoritmo Manacher
    
    cout << "\n";

//******************** Actividad 3 ******************** 

	cout << "\nParte 3 \n";

	char Array1[transmision1String.size()+1];// Convertimos los Strings de los .txt a char arrays, con la función strcpy
	strcpy(Array1, transmision1String.c_str());
	
	//cout << Array1[0];
	
	char Array2[transmision2String.size()+1];
	strcpy(Array2, transmision2String.c_str());
	
 
    int m = strlen(Array1); //Sacamos las longitudes de los arrays
    int n = strlen(Array2);
 
    Printsubstr(Array1, Array2, m, n); //Enviamos a la función para encontrar el substring común mas largo
}


