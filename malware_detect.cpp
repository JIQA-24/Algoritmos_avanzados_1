#include <iostream>
#include <fstream>
#include <cstring>
#include <vector>

using namespace std;

int Contador = 0;
int tota = 0;

//******************** Parte 1 ********************

vector<int> PreProcesamiento(string Mcode){
    int l = Mcode.length();

    vector<int> kmp(1,0);
    int pPatron = 0;

    for (int iter = 1; iter < l; iter++){
        if(Mcode[iter] == Mcode[pPatron]){
            pPatron++;
            kmp.push_back(pPatron);
        }else{
            pPatron = 0;
            kmp.push_back(pPatron);
        }
    }

    return kmp;
}

//o(n)
//encontrar el Virus en el string
void KMP(string Transmision, string Mcode, vector<int> kmp, int cont){

    int tamanoPatron = Mcode.length();
    int posPatron = 0;

    for (int i = 0; i < Transmision.length(); i++){
    	
    	cont++;

        if (Mcode[posPatron] == Transmision[i]){
            posPatron++;
            
            if (posPatron == tamanoPatron){
                int nuevaPosicion = i - (tamanoPatron - 1);
                nuevaPosicion = nuevaPosicion + 1; //Por que es Base 1;
                cout << tota+nuevaPosicion << " ";
                posPatron = kmp[posPatron - 1];
                Contador = Contador + 1;
            }
        }else{
            if (posPatron != 0){
                posPatron = kmp[posPatron - 1];
                i--;
            }
        }
    }
    tota=tota+cont;
}

//******************** Parte 2 ********************

string aumenta(string S){
  string s = "";
  for (char c:S){
    s = s+"|"+c;
  }
  return s+"|";
}

pair<int,int> manacher(string S){
  pair<int,int> res(0,0); // resultado (inicio, longitud)
  if (S.length() == 0) // S es nulo
    return res;
  string T = aumenta(S);  // llamar a funci�n
  int N = T.length();
  // longitud y centro del m�ximo pal�ndromo encontrado
  int maxLong=1, maxCentro=1; // Hasta ahora posici�n 1
  int L[N];
  int C = 1;
  int Li = 0, Ri = 0;
  bool expansion = false; // true si requiera expansi�n

  L[0]=0; L[1]=1;
  for (Ri=2; Ri<N; Ri++){
    expansion = false;
    Li = C - (Ri-C);
    if ((C+L[C])-Ri >= 0){
      if(L[Li] < (C+L[C])-Ri) // Caso 1
				L[Ri] = L[Li];
			else if(L[Li] == (C+L[C])-Ri && (C+L[C]) == N-1) // Caso 2
				L[Ri] = L[Li];
			else if(L[Li] == (C+L[C])-Ri && (C+L[C]) < N-1){ // Caso 3
					L[Ri] = L[Li];
					expansion = true; // requiere expansi�n
			}
			else if(L[Li] > (C+L[C])-Ri){ // Case 4
				L[Ri] = (C+L[C])-Ri;
				expansion = true; // requiere expansi�n
			}
    }
    else{
      L[Ri] = 0;
      expansion = true;  // requiere expansi�n
    }
    if (expansion) // hacer la expansi�n hasta donde se pueda
      while ((Ri + L[Ri]) < N && (Ri - L[Ri]) > 0
             && T[Ri+L[Ri]+1] == T[Ri-L[Ri]-1])
        L[Ri]++;
    if (Ri + L[Ri] > (C + L[C]))
      // si el nuevo pal�ndromo se expande m�s all� de C
			C = Ri;
    if(L[Ri] > maxLong){
      // Guardar longitud y centro del pal�ndromo m�s grande,
      // hasta ahora
			maxLong = L[Ri];
			maxCentro = Ri;
		}
  }
  // obtener inicio y longitud del m�ximo pal�ndromo encontrado
  // recordando que la longitud de T es el doble de la de S
  res.first = (maxCentro - maxLong)/2; // inicio en S
  res.second = maxLong; // longitud en S
  return res;
}


void printLCSubStr(char* X, char* Y, int m, int n)
{
    // Create a table to store lengths of longest common
    // suffixes of substrings.   Note that LCSuff[i][j]
    // contains length of longest common suffix of X[0..i-1]
    // and Y[0..j-1]. The first row and first column entries
    // have no logical meaning, they are used only for
    // simplicity of program
    int LCSuff[m + 1][n + 1];
 
    // To store length of the longest common substring
    int len = 0;
 
    // To store the index of the cell which contains the
    // maximum value. This cell's index helps in building
    // up the longest common substring from right to left.
    int row, col;
 
    /* Following steps build LCSuff[m+1][n+1] in bottom
       up fashion. */
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0 || j == 0)
                LCSuff[i][j] = 0;
 
            else if (X[i - 1] == Y[j - 1]) {
                LCSuff[i][j] = LCSuff[i - 1][j - 1] + 1;
                if (len < LCSuff[i][j]) {
                    len = LCSuff[i][j];
                    row = i;
                    col = j;
                }
            }
            else
                LCSuff[i][j] = 0;
        }
    }
 
    // if true, then no common substring exists
    if (len == 0) {
        cout << "No Common Substring";
        return;
    }
    int contador;
 
    // allocate space for the longest common substring
    char* resultStr = (char*)malloc((len + 1) * sizeof(char));
 
    // traverse up diagonally form the (row, col) cell
    // until LCSuff[row][col] != 0
    while (LCSuff[row][col] != 0) {
        resultStr[--len] = X[row - 1]; // or Y[col-1]
        
 
        // move diagonally up to previous cell
        row--;
        col--;
        
        contador ++;
        
        
    }
 
    // required longest common substring
    
    cout << "SubString Comun Mas Largo: " << resultStr << "\n";
    cout << row-contador << "  "<<row;
}



int main(){
    int Actividades, Secuencia, N;
    string virus, codigo;

    Secuencia = 0;
    Actividades = 0;


    ifstream archivo1("transmission1.txt");
    string Transmission1;
    ifstream archivo12("transmission1.txt");
    string Transmission12;
    ifstream archivo13("transmission1.txt");
    string Transmission13;
    
    string transmision1String( (istreambuf_iterator<char>(archivo1) ),
        (istreambuf_iterator<char>()    ) );
                  


    ifstream archivo2("transmission2.txt");
    string Transmission2;
    ifstream archivo22("transmission2.txt");
    string Transmission22;
    ifstream archivo23("transmission2.txt");
    string Transmission23;
    
    string transmision2String( (istreambuf_iterator<char>(archivo2) ),
        (istreambuf_iterator<char>()    ) );

    ifstream archivo3("mcode1.txt");
    string Mcode1;
    archivo3 >> Mcode1;

    ifstream archivo4("mcode2.txt");
    string Mcode2;
    archivo4 >> Mcode2;

    ifstream archivo5("mcode3.txt");
    string Mcode3;
    archivo5 >> Mcode3;

//******************** Actividad 1 ******************** 
//******************* Transmission1 ******************* 

    Contador = 0;
    tota = 0;
    while(archivo1 >> Transmission1) {  
        vector<int> preKMP = PreProcesamiento(Mcode1);
        int conta=0;
        KMP(Transmission1,Mcode1,preKMP,conta);
         
    }

    if (Contador != 0){
        cout << "true" << " " << "\n";
    }
    else{
        cout << "false" << "\n";
    } 

    Contador = 0;
    tota = 0;
    archivo12.seekg(0);
    while(archivo12 >> Transmission1) {
        vector<int> preKMP = PreProcesamiento(Mcode2);
        int conta=0;
        KMP(Transmission1,Mcode2,preKMP,conta);
    }

    if (Contador != 0){
        cout << "true" << " " << "\n";
    }
    else{
        cout << "false" << "\n";
    } 

    Contador = 0;
    tota = 0;
    archivo13.seekg(0);
    while(archivo13 >> Transmission1) {        
        vector<int> preKMP = PreProcesamiento(Mcode3);
        int conta=0;
        KMP(Transmission1,Mcode3,preKMP,conta); 
    }

    if (Contador != 0){
        cout << "true" << " " << "\n";
    }
    else{
        cout << "false" << "\n";
    } 

//******************* Transmission2 *******************
    Contador = 0;
    tota = 0;
    while(archivo2 >> Transmission1) {      
        vector<int> preKMP = PreProcesamiento(Mcode1);
        int conta=0;
        KMP(Transmission1,Mcode1,preKMP,conta);
    }

    if (Contador != 0){
        cout << "true" << " " << "\n";
    }
    else{
        cout << "false" << "\n";
    }

    Contador = 0;
    tota = 0;
    archivo22.seekg(0);
    while(archivo22 >> Transmission1) {        
        vector<int> preKMP = PreProcesamiento(Mcode2);
        int conta=0;
        KMP(Transmission1,Mcode2,preKMP,conta); 
    }

    if (Contador != 0){
        cout << "true" << " " << "\n";
    }
    else{
        cout << "false" << "\n";
    }

    Contador = 0;
    tota = 0;
    archivo23.seekg(0);
    while(archivo23 >> Transmission1) {
        vector<int> preKMP = PreProcesamiento(Mcode3);
        int conta=0;
        KMP(Transmission1,Mcode3,preKMP,conta); 
    }

    if (Contador != 0){
        cout << "true" << " " << "\n";
    }
    else{
        cout << "false" << "\n";
    } 
    


//******************** Actividad 2 ******************** 
	pair<int,int> res = manacher(transmision1String);
  	cout << res.first << "  " << res.first+res.second << "\n";
  	
  	pair<int,int> res2 = manacher(transmision2String);
  	cout << res2.first << "  " << res2.first+res2.second<< "\n";

//******************** Actividad 3 ******************** 

	char Array1[transmision1String.size()+1];//as 1 char space for null is also required
	strcpy(Array1, transmision1String.c_str());
	
	//cout << Array1[0];
	
	char Array2[transmision2String.size()+1];//as 1 char space for null is also required
	strcpy(Array2, transmision2String.c_str());
	
 
    int m = strlen(Array1);
    int n = strlen(Array2);
 
    printLCSubStr(Array1, Array2, m, n);
}


